PPL assignment 2 Question 1 (theoretical part):
1.1	Primitive atomic expression: true.
Non-primitive atomic expression:  define x=5. x is non-primitive atomic expression.
Non-primitive compound expression: (+ 3 4)
Primitive atomic value: 5
Non-primitive atomic value: define a = 3. Define b = a. a is the value of the var b.
Non-primitive compound value: closure.
1.2	Special form is a compound expression which is not evaluated like a regular compound expression. For example: cond.
1.3	Free variable is a variable which has a reference in scope E, but is not declared in scope E. ex: (lambda (x) (x+y)). Y is a free variable.
1.4	Symbolic-Expression is a notation that represents a nested list of data. Ex: (+ 3  (* 5 4)).
1.5 let translates into lambda:
(let ((x 1) (y 2))
    (+ x y)
=> 
((lambda (x y) (+ x y))
    1 2)
(define a 5)
=>
5
(each appearance of ‘a’ translates into 5)
1.6) Every program in L1 can be transformed to an equivalent program in L0, because each ‘define’ expression can be replaced by a var declaration.
1.7) Condtradictionary example:
        (define fact
	(lambda (n)
                  (if (eq? n 0)
	        1
	       (* n fact(n-1))
     )
)
          )
1.8) The advantage of Closure is that if you want to add an operator, all you need to do is to add the proper binding to the global environment.
The advantage of primOp over Closure is that if the language has a lot of functions, each time you it runs into a varRef, it takes time to go over the global environment and search for the actual function.
1.9) The new implementation of map would be the same because map creates a new array by applying the given function on each of the cells in the given array. The given array doesn’t change during the procedure, and so it doesn’t matter in which order it works.
In the case of reduce it wouldn’t work, and here is a contradicting example:
Reduce (concat, [], [1,2,3]) = [1,2,3].
ReverseReduce (concat, [], [1,2,3]) = [3,2,1]


2.
2.1)
Signature: empty? (x)
Type: [Any -> Boolean]
Purpose: Returns true iff the given expression is the empty list.
Pre-Conditions: True.
Test: (empty? ‘()) ⇒ #t 
  (empty? ‘(1 2 3)) ⇒ #f 
2.2)
Signature: list? (x)
Type: [Any -> Boolean]
Purpose: Returns true iff the given expression is a list.
Pre-Conditions: True.
Test: (list? (cons 1 (cons 2 ‘()))) ⇒ #t 
   (list? (cons 1 2) ⇒ #f
2.3)
Signature equal-list? (x, y)
Type: [Any * Any -> Boolean]
Purpose: Returns true iff the given two expressions are equal lists. 
Pre-Conditions: True. 
Test: (equal-list? ‘(1 2) ‘(1 2)) ⇒ #t
  (equal-list? (cons 1 2) (cons 1 2)) ⇒ #f
2.4)
Signature: append (x, y)
Type: [List * List -> List]
Purpose: Takes two lists and returns the first list appended with the second.
Pre-Conditions: True.
Test: (append ‘(1 2 3) ‘(4 5 6)) ⇒ ‘(1 2 3 4 5 6)
2.5)
Signature: append3 (x, y, n)
Type: [List * List * Number -> List]
Purpose: Takes two lists and one item, and returns the first list appended with the second and the integer.
Pre-Conditions: True.
Test: (append3 ‘(1 2 3) ‘(4 5 6) 7) ⇒ ‘(1 2 3 4 5 6 7)
2.6)
Signature: pascal (n)
Type: [Number -> List]
Purpose: Computes the nth row of Pascal's triangle.
Pre-Conditions: n >= 1
Test: (pascal 5) => '(1 4 6 4 1)

